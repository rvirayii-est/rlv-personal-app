# Complete Tutorial: Building a To-Do List Feature in Flutter with SQLite

## ğŸ“š Table of Contents
1. [Introduction](#introduction)
2. [Architecture Overview](#architecture-overview)
3. [Step-by-Step Implementation](#step-by-step-implementation)
4. [Code Deep Dive](#code-deep-dive)
5. [Key Concepts Explained](#key-concepts-explained)
6. [Best Practices](#best-practices)
7. [Testing and Debugging](#testing-and-debugging)

---

## Introduction

This tutorial teaches you how to build a complete to-do list feature in Flutter with offline SQLite database storage. You'll learn the **layered architecture pattern** that separates concerns and makes your code maintainable.

### What You'll Build
- âœ… Full CRUD operations (Create, Read, Update, Delete)
- âœ… Priority levels (Low, Medium, High)
- âœ… Due dates with overdue detection
- âœ… Tab-based filtering (All, Pending, Completed)
- âœ… Search functionality
- âœ… Statistics and counts
- âœ… Persistent offline storage with SQLite

### Architecture Layers
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           UI Layer (Screens)            â”‚  â† User Interface
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      Service Layer (Business Logic)     â”‚  â† CRUD Operations
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       Model Layer (Data Structure)      â”‚  â† Data Representation
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Database Layer (Data Persistence)    â”‚  â† SQLite Storage
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

---

## Architecture Overview

### Why This Architecture?

We use a **layered architecture** (also called **clean architecture**) because:

1. **Separation of Concerns**: Each layer has ONE responsibility
2. **Testability**: Easy to test each layer independently
3. **Maintainability**: Changes in one layer don't break others
4. **Reusability**: Services can be used by multiple screens
5. **Scalability**: Easy to add new features

### The Four Layers Explained

#### 1. **Model Layer** (`lib/models/todo.dart`)
**Purpose**: Defines the data structure

- Represents a Todo item as a Dart class
- Converts between Dart objects and database Maps
- Contains data validation and helper methods
- No business logic, just data representation

**Key Concept**: The Model is a "blueprint" of your data.

#### 2. **Database Layer** (`lib/database/database_helper.dart`)
**Purpose**: Handles database operations

- Creates and manages the SQLite database
- Defines table schema (structure)
- Provides generic CRUD methods
- Manages database version and migrations

**Key Concept**: This is your "storage manager" - it knows HOW to store data, but not WHAT to do with it.

#### 3. **Service Layer** (`lib/services/todo_service.dart`)
**Purpose**: Business logic and operations

- Implements todo-specific operations
- Uses DatabaseHelper to access data
- Provides methods like `getPendingTodos()`, `toggleStatus()`
- Knows the "rules" of your application

**Key Concept**: This is your "business manager" - it knows the RULES and OPERATIONS.

#### 4. **UI Layer** (`lib/screens/todo_list_screen.dart`)
**Purpose**: User interface and interaction

- Displays data to the user
- Handles user input
- Calls Service Layer methods
- Updates UI based on state changes

**Key Concept**: This is what the user SEES and INTERACTS with.

---

## Step-by-Step Implementation

Let's build the feature step by step, understanding WHY we do each step.

### Step 1: Define the Data Model

**File**: `lib/models/todo.dart`

#### Why Start Here?
Before we can store or display data, we need to define WHAT data we're working with.

#### The Todo Model

```dart
class Todo {
  int? id;                  // Unique identifier (auto-generated by database)
  String title;             // Required: What the todo is about
  String? description;      // Optional: More details
  bool isCompleted;         // Status: done or not done
  String? dueDate;          // Optional: When it's due (ISO8601 format)
  String priority;          // 'low', 'medium', or 'high'
  DateTime createdAt;       // When it was created
  DateTime updatedAt;       // When it was last updated
}
```

#### Key Methods Explained

**1. Constructor**
```dart
Todo({
  this.id,
  required this.title,     // 'required' means you MUST provide this
  this.isCompleted = false, // Default value
  // ...
})  : createdAt = createdAt ?? DateTime.now(),  // If null, use now
      updatedAt = updatedAt ?? DateTime.now();
```

**Why?**
- `required` ensures we never create a Todo without a title
- Default values make it easier to create new todos
- The initializer list (`:`) sets timestamps if not provided

**2. toMap() - Converting to Database Format**
```dart
Map<String, dynamic> toMap() {
  return {
    'id': id,
    'title': title,
    'is_completed': isCompleted ? 1 : 0,  // SQLite uses 0/1 for boolean
    // ...
  };
}
```

**Why?**
- SQLite stores data as key-value pairs (Maps)
- We convert our object to a format SQLite understands
- Booleans are converted to integers (0 or 1)

**3. fromMap() - Converting from Database**
```dart
factory Todo.fromMap(Map<String, dynamic> map) {
  return Todo(
    id: map['id'] as int?,
    title: map['title'] as String,
    isCompleted: (map['is_completed'] as int) == 1,  // Convert 1/0 back to bool
    // ...
  );
}
```

**Why?**
- When we read from database, we get a Map
- We convert it back to a Todo object
- This is the reverse of `toMap()`

**4. copyWith() - Creating Modified Copies**
```dart
Todo copyWith({
  int? id,
  String? title,
  bool? isCompleted,
  // ...
}) {
  return Todo(
    id: id ?? this.id,              // Use new value if provided, otherwise keep old
    title: title ?? this.title,
    isCompleted: isCompleted ?? this.isCompleted,
    // ...
  );
}
```

**Why?**
- In Flutter/Dart, we prefer immutability (not changing objects directly)
- Instead of modifying an object, we create a new one with changes
- The `??` operator means "if null, use the original value"

**Example Usage**:
```dart
final todo = Todo(title: 'Buy milk');
final completedTodo = todo.copyWith(isCompleted: true);
// Original 'todo' is unchanged, 'completedTodo' is a new object
```

---

### Step 2: Update the Database Schema

**File**: `lib/database/database_helper.dart`

#### Why?
We need to tell SQLite how to store our todos.

#### Adding Table Constants

```dart
// Table name
static const String tableTodos = 'todos';

// Column names
static const String columnTodoId = 'id';
static const String columnTodoTitle = 'title';
static const String columnTodoDescription = 'description';
static const String columnTodoIsCompleted = 'is_completed';
// ... etc
```

**Why use constants?**
- Prevents typos (compile-time checking)
- Easy to change column names in one place
- Better autocomplete in your IDE

#### Creating the Table

```dart
await db.execute('''
  CREATE TABLE $tableTodos (
    $columnTodoId INTEGER PRIMARY KEY AUTOINCREMENT,
    $columnTodoTitle TEXT NOT NULL,
    $columnTodoDescription TEXT,
    $columnTodoIsCompleted INTEGER NOT NULL DEFAULT 0,
    $columnTodoDueDate TEXT,
    $columnTodoPriority TEXT NOT NULL DEFAULT 'medium',
    $columnTodoCreatedAt TEXT NOT NULL,
    $columnTodoUpdatedAt TEXT NOT NULL
  )
''');
```

**SQL Breakdown**:
- `INTEGER PRIMARY KEY AUTOINCREMENT`: Auto-generates unique IDs
- `TEXT NOT NULL`: Required text field
- `TEXT`: Optional text field (can be null)
- `DEFAULT 0`: If not specified, use 0
- `TEXT NOT NULL DEFAULT 'medium'`: Required with default value

**Why these data types?**
- `INTEGER`: Numbers (id, booleans as 0/1)
- `TEXT`: Strings (title, dates as ISO8601 strings)
- SQLite only has these basic types (no DATE, BOOLEAN, etc.)

---

### Step 3: Create the Service Layer

**File**: `lib/services/todo_service.dart`

#### Why?
This layer contains all the business logic for managing todos.

#### Service Structure

```dart
class TodoService {
  final DatabaseHelper _dbHelper = DatabaseHelper.instance;

  // CRUD methods here
}
```

**Why use DatabaseHelper.instance?**
- DatabaseHelper uses the Singleton pattern
- `instance` ensures we always use the same database connection
- Prevents multiple database connections (which would cause conflicts)

#### Key Methods Explained

**1. Create a Todo**
```dart
Future<int> createTodo(Todo todo) async {
  todo.updatedAt = DateTime.now();  // Update timestamp
  return await _dbHelper.insert(
    DatabaseHelper.tableTodos,
    todo.toMap(),  // Convert object to Map
  );
}
```

**Flow**:
1. Update the timestamp (mark when it was last modified)
2. Convert Todo object to Map using `toMap()`
3. Call generic `insert()` method on database
4. Return the ID of the new todo

**2. Get All Todos**
```dart
Future<List<Todo>> getAllTodos() async {
  final List<Map<String, dynamic>> maps = await _dbHelper.queryAll(
    DatabaseHelper.tableTodos,
    orderBy: '${DatabaseHelper.columnTodoCreatedAt} DESC',
  );
  return List.generate(maps.length, (i) => Todo.fromMap(maps[i]));
}
```

**Flow**:
1. Query database, get list of Maps
2. Sort by creation date (newest first)
3. Convert each Map to Todo object using `fromMap()`
4. Return list of Todo objects

**Why `List.generate()`?**
- It's a concise way to transform a list
- For each index `i`, it creates a Todo from `maps[i]`
- Equivalent to a for loop, but more functional

**3. Toggle Completion Status**
```dart
Future<int> toggleTodoStatus(int id) async {
  final todo = await getTodoById(id);
  if (todo == null) return 0;

  final updatedTodo = todo.copyWith(
    isCompleted: !todo.isCompleted,  // Flip the boolean
    updatedAt: DateTime.now(),
  );

  return await updateTodo(updatedTodo);
}
```

**Flow**:
1. Get the todo by ID
2. If it doesn't exist, return 0 (no rows affected)
3. Create a new todo with opposite completion status
4. Update the database
5. Return number of rows affected (should be 1)

**Why this approach?**
- We don't modify the original todo (immutability)
- We create a new object with the change
- This is safer and more predictable

**4. Get Overdue Todos**
```dart
Future<List<Todo>> getOverdueTodos() async {
  final allPending = await getPendingTodos();
  final now = DateTime.now();

  return allPending.where((todo) {
    if (todo.dueDate == null) return false;
    try {
      final dueDate = DateTime.parse(todo.dueDate!);
      return dueDate.isBefore(now);
    } catch (e) {
      return false;
    }
  }).toList();
}
```

**Flow**:
1. Get all pending (not completed) todos
2. Filter using `where()` - only keep todos that match condition
3. For each todo, check if due date is before now
4. Handle potential parsing errors with try-catch
5. Convert filtered result to list

**Why filter in Dart instead of SQL?**
- Date comparison is complex in SQLite (dates are stored as strings)
- Dart's DateTime makes it easier
- For small datasets, the performance difference is negligible

---

### Step 4: Build the UI Screen

**File**: `lib/screens/todo_list_screen.dart`

#### Why?
This is what the user sees and interacts with.

#### Screen Structure

```dart
class TodoListScreen extends StatefulWidget {
  @override
  State<TodoListScreen> createState() => _TodoListScreenState();
}

class _TodoListScreenState extends State<TodoListScreen>
    with SingleTickerProviderStateMixin {

  final TodoService _todoService = TodoService();
  List<Todo> _todos = [];
  bool _isLoading = true;
  late TabController _tabController;

  // Methods here
}
```

**Key Concepts**:

**1. StatefulWidget vs StatelessWidget**
- `StatefulWidget`: Can change over time (has mutable state)
- `StatelessWidget`: Never changes (immutable)
- We use Stateful because todos list changes when user adds/deletes

**2. SingleTickerProviderStateMixin**
- Required for `TabController` (handles tab animations)
- "Mixin" adds functionality to a class
- "Ticker" provides animation frames

**3. State Variables**
```dart
List<Todo> _todos = [];      // The list of todos to display
bool _isLoading = true;       // Show loading indicator
late TabController _tabController;  // Manages the tabs
```

**Why underscore `_`?**
- Makes variables private to this file
- Can't be accessed from other files
- Dart convention for private members

**Why `late`?**
- We know it will be initialized before use
- Can't initialize in declaration (needs `vsync: this`)
- Will be set in `initState()`

#### Lifecycle Methods

**1. initState() - When Screen is Created**
```dart
@override
void initState() {
  super.initState();  // ALWAYS call super first
  _tabController = TabController(length: 3, vsync: this);
  _tabController.addListener(() => setState(() {}));
  _loadTodos();
}
```

**Flow**:
1. Call parent's initState
2. Create TabController with 3 tabs
3. Add listener to rebuild when tab changes
4. Load initial data

**Why `setState(() {})`?**
- Tells Flutter to rebuild the widget
- Empty function because we just need to trigger rebuild
- Tab change updates UI

**2. dispose() - When Screen is Destroyed**
```dart
@override
void dispose() {
  _tabController.dispose();
  _searchController.dispose();
  super.dispose();  // Call super last
}
```

**Why?**
- Prevents memory leaks
- Controllers must be disposed when not needed
- Always dispose in reverse order of creation

#### Loading Data

```dart
Future<void> _loadTodos() async {
  setState(() => _isLoading = true);

  try {
    List<Todo> todos;
    switch (_tabController.index) {
      case 0: todos = await _todoService.getAllTodos(); break;
      case 1: todos = await _todoService.getPendingTodos(); break;
      case 2: todos = await _todoService.getCompletedTodos(); break;
      default: todos = await _todoService.getAllTodos();
    }

    setState(() {
      _todos = todos;
      _isLoading = false;
    });
  } catch (e) {
    print('Error loading todos: $e');
    setState(() => _isLoading = false);
  }
}
```

**Flow**:
1. Set loading state (shows spinner)
2. Get appropriate todos based on selected tab
3. Update state with new todos
4. Hide loading indicator
5. Handle errors gracefully

**Why try-catch?**
- Database operations can fail
- Prevents app from crashing
- Allows showing error message to user

#### Building the UI

**1. Scaffold Structure**
```dart
return Scaffold(
  appBar: AppBar(...),
  body: Column(...),
  floatingActionButton: FloatingActionButton(...),
);
```

**What is Scaffold?**
- Provides basic Material Design layout
- Handles AppBar, Body, FloatingActionButton, etc.
- Gives you the standard app structure

**2. Tab Bar**
```dart
appBar: AppBar(
  title: const Text('My To-Do List'),
  bottom: TabBar(
    controller: _tabController,
    onTap: (_) => _loadTodos(),
    tabs: const [
      Tab(text: 'All'),
      Tab(text: 'Pending'),
      Tab(text: 'Completed'),
    ],
  ),
)
```

**How it works**:
- TabBar displays the tabs
- `controller` syncs tabs with content
- `onTap` reloads data when tab changes
- `const` optimizes performance (tabs never change)

**3. Conditional Rendering**
```dart
_isLoading
  ? const Center(child: CircularProgressIndicator())
  : _todos.isEmpty
    ? _buildEmptyState()
    : RefreshIndicator(child: ListView.builder(...))
```

**This is a ternary operator chain**:
- If loading â†’ show spinner
- Else if no todos â†’ show empty state
- Else â†’ show list with pull-to-refresh

**4. ListView.builder**
```dart
ListView.builder(
  itemCount: _todos.length,
  itemBuilder: (context, index) {
    return _buildTodoCard(_todos[index]);
  },
)
```

**Why builder?**
- Only builds visible items (lazy loading)
- Efficient for long lists
- Scrolling is smooth
- `itemBuilder` is called for each visible item

#### Dialogs for Add/Edit

**1. StatefulBuilder for Dynamic Dialogs**
```dart
showDialog(
  context: context,
  builder: (context) => StatefulBuilder(
    builder: (context, setDialogState) => AlertDialog(...)
  ),
);
```

**Why StatefulBuilder?**
- Dialogs need their own state (for dropdowns, date picker)
- `setDialogState` updates ONLY the dialog, not the whole screen
- More efficient than rebuilding entire screen

**2. Date Picker**
```dart
final date = await showDatePicker(
  context: context,
  initialDate: DateTime.now(),
  firstDate: DateTime.now(),
  lastDate: DateTime.now().add(const Duration(days: 365)),
);
if (date != null) {
  setDialogState(() => selectedDueDate = date);
}
```

**Flow**:
1. Show native date picker
2. `await` waits for user to pick a date
3. Returns `null` if user cancels
4. Update dialog state if date was selected

---

### Step 5: Update Home Screen

**File**: `lib/screens/home_screen.dart`

#### Why?
We need to add navigation to the new todo screen and show statistics.

#### Adding Todo Stats

```dart
final TodoService _todoService = TodoService();
int _todoCount = 0;
int _pendingTodoCount = 0;

Future<void> _loadCounts() async {
  // ... existing code
  final todoCount = await _todoService.getTodoCount();
  final pendingCount = await _todoService.getPendingCount();
  setState(() {
    _todoCount = todoCount;
    _pendingTodoCount = pendingCount;
    // ...
  });
}
```

**Why load counts?**
- Dashboard shows overview statistics
- User can see status at a glance
- Motivates user to complete todos

#### Adding Navigation Card

```dart
_buildStatCard(
  title: 'Todos',
  count: _todoCount,
  icon: Icons.check_circle,
  color: Colors.purple,
  onTap: () => _navigateToTodos(),
  subtitle: '$_pendingTodoCount pending',
)
```

**Why subtitle?**
- Shows pending count at a glance
- Provides more context
- Optional parameter (doesn't break existing cards)

#### Navigation Method

```dart
void _navigateToTodos() async {
  await Navigator.push(
    context,
    MaterialPageRoute(builder: (context) => const TodoListScreen()),
  );
  _loadCounts();  // Reload counts when coming back
}
```

**Why `await`?**
- `push()` returns a Future that completes when user goes back
- We wait for user to return before reloading counts
- Ensures statistics are up-to-date

---

## Code Deep Dive

### Understanding Async/Await

**What is async?**
- Marks a function as asynchronous
- Can perform long-running operations without blocking
- Returns a `Future<T>` automatically

**What is await?**
- Waits for a Future to complete
- Gets the actual value from the Future
- Can only be used inside async functions

**Example**:
```dart
// WITHOUT async/await (callback hell)
getTodos().then((todos) {
  print(todos);
  updateUI(todos);
}).catchError((error) {
  print(error);
});

// WITH async/await (much cleaner)
try {
  final todos = await getTodos();
  print(todos);
  updateUI(todos);
} catch (error) {
  print(error);
}
```

### Understanding setState()

**What it does**:
- Marks widget as dirty (needs rebuild)
- Schedules a rebuild on the next frame
- Only rebuilds THIS widget and its children

**When to use**:
```dart
setState(() {
  _todos = newTodos;  // Change that affects UI
});
```

**When NOT to use**:
```dart
// Don't do this:
_todos = newTodos;
setState(() {});  // No changes in setState

// Do this instead:
setState(() {
  _todos = newTodos;  // Changes inside setState
});
```

### Understanding Futures and Promises

**Future** is a placeholder for a value that will arrive later:
```dart
Future<List<Todo>> getTodos() async {
  // Simulates network delay
  await Future.delayed(Duration(seconds: 2));
  return [todo1, todo2, todo3];
}

// Using the Future
final todos = await getTodos();  // Waits 2 seconds, then gets todos
```

**Why Futures?**
- Database operations take time
- Don't want to freeze the UI
- App stays responsive

### Understanding Generics

**What are generics?**
- Way to write type-safe, reusable code
- `<T>` means "some type"

**Examples**:
```dart
Future<List<Todo>> getAllTodos();  // Returns Future of List of Todos
Future<int> createTodo(Todo todo); // Returns Future of int
Map<String, dynamic> toMap();      // Map with String keys and any values
```

**Why use them?**
- Type safety: Compiler checks types
- Better IDE support: Autocomplete knows types
- Catch errors at compile time, not runtime

---

## Best Practices

### 1. Naming Conventions

```dart
// Classes: PascalCase
class TodoService { }

// Variables and functions: camelCase
int todoCount;
void loadTodos() { }

// Constants: camelCase with const
const String tableTodos = 'todos';

// Private members: _ prefix
String _databaseName;
void _loadCounts() { }
```

### 2. File Organization

```
lib/
â”œâ”€â”€ models/          # Data structures
â”‚   â””â”€â”€ todo.dart
â”œâ”€â”€ services/        # Business logic
â”‚   â””â”€â”€ todo_service.dart
â”œâ”€â”€ screens/         # UI screens
â”‚   â””â”€â”€ todo_list_screen.dart
â””â”€â”€ database/        # Data persistence
    â””â”€â”€ database_helper.dart
```

**Why this structure?**
- Easy to find files
- Scales well as app grows
- Clear separation of concerns

### 3. Error Handling

```dart
try {
  final todos = await _todoService.getAllTodos();
  setState(() => _todos = todos);
} catch (e) {
  print('Error: $e');
  // Show error to user
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(content: Text('Failed to load todos')),
  );
}
```

**Why?**
- Database can fail
- Network can fail (if syncing)
- Better user experience

### 4. Const Optimization

```dart
// Good: Uses const (created once)
const Text('Hello')
const SizedBox(height: 16)
const Icon(Icons.add)

// Bad: Creates new object every rebuild
Text('Hello')
SizedBox(height: 16)
Icon(Icons.add)
```

**Why const?**
- Flutter reuses const objects
- Faster rebuilds
- Less memory usage

### 5. Widget Extraction

```dart
// Bad: Everything in build()
Widget build(BuildContext context) {
  return Column(
    children: [
      // 100 lines of nested widgets
    ],
  );
}

// Good: Extracted to methods
Widget build(BuildContext context) {
  return Column(
    children: [
      _buildHeader(),
      _buildContent(),
      _buildFooter(),
    ],
  );
}
```

**Benefits**:
- Easier to read
- Easier to test
- Easier to reuse

---

## Testing and Debugging

### Common Issues and Solutions

**1. "setState called after dispose"**
```dart
// Problem:
await Future.delayed(Duration(seconds: 2));
setState(() {});  // Widget might be disposed

// Solution:
if (mounted) {  // Check if widget is still in tree
  setState(() {});
}
```

**2. "Null check operator used on a null value"**
```dart
// Problem:
final todo = todos[0];  // List might be empty

// Solution:
if (todos.isNotEmpty) {
  final todo = todos[0];
}
// Or use try-catch
```

**3. "Database is locked"**
```dart
// Problem: Multiple database connections

// Solution: Use Singleton pattern
static final DatabaseHelper instance = DatabaseHelper._privateConstructor();
```

### Debugging Tips

**1. Print Statements**
```dart
print('Todos count: ${_todos.length}');
print('Loading: $_isLoading');
```

**2. Flutter DevTools**
- Inspect widget tree
- View performance
- Debug network calls

**3. Breakpoints**
- Pause execution
- Inspect variables
- Step through code

---

## Key Concepts Explained

### 1. Singleton Pattern

**Why?**
- Only ONE instance of database
- Prevents conflicts
- Shared across app

**How?**
```dart
class DatabaseHelper {
  // Private constructor
  DatabaseHelper._privateConstructor();

  // Single instance
  static final DatabaseHelper instance = DatabaseHelper._privateConstructor();

  // Usage: DatabaseHelper.instance
}
```

### 2. Factory Constructor

**What?**
- Special constructor that can return an instance
- Can return cached instance
- Can return subtype

**Example**:
```dart
factory Todo.fromMap(Map<String, dynamic> map) {
  // Creates and returns a new Todo
  return Todo(
    id: map['id'],
    title: map['title'],
  );
}
```

### 3. Named Parameters

```dart
// Positional (order matters)
void greet(String name, int age) {
  print('Hi $name, age $age');
}
greet('John', 25);  // Must be in order

// Named (order doesn't matter)
void greet({required String name, required int age}) {
  print('Hi $name, age $age');
}
greet(age: 25, name: 'John');  // Can be any order
```

### 4. Null Safety

```dart
String? title;       // Can be null
String name;         // Cannot be null

title = null;        // OK
name = null;         // ERROR

// Use ! to assert non-null (dangerous)
print(title!.length);  // Crashes if title is null

// Use ? for safe access
print(title?.length);  // Returns null if title is null

// Use ?? for default value
print(title ?? 'No title');  // Uses 'No title' if title is null
```

---

## Summary

### What You Learned

1. **Architecture**: How to structure a Flutter app with layers
2. **Models**: Defining data structures and conversions
3. **Database**: Creating tables and CRUD operations
4. **Services**: Implementing business logic
5. **UI**: Building interactive interfaces
6. **State Management**: Using setState and StatefulWidget
7. **Async Programming**: Using async/await and Futures
8. **Best Practices**: Code organization and conventions

### Next Steps

1. Add categories/tags to todos
2. Add todo sharing (export/import)
3. Add notifications for due dates
4. Add data synchronization with backend
5. Add todo statistics and charts
6. Implement drag-and-drop reordering
7. Add todo templates
8. Implement recurring todos

### Resources

- [Flutter Documentation](https://docs.flutter.dev/)
- [Dart Language Tour](https://dart.dev/guides/language/language-tour)
- [SQLite Documentation](https://www.sqlite.org/docs.html)
- [Flutter Cookbook](https://docs.flutter.dev/cookbook)

---

## Conclusion

You've built a complete, production-ready to-do list feature! You now understand:

- âœ… Flutter app architecture
- âœ… SQLite database integration
- âœ… CRUD operations
- âœ… State management
- âœ… UI development
- âœ… Async programming
- âœ… Best practices

Keep building, keep learning! ğŸš€

---

*Created with â¤ï¸ for learning Flutter development*
